<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction - Dataflow</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="intro.html" class="active">Introduction</a></li><li class="expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> The First Chapter</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Dataflow</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>For now, I'll just write everything here, then, as it takes shape, we can decide
what good chapter names will be and how to divide it all up.</p>
<h2><a class="header" href="#what-is-this" id="what-is-this">What is this?</a></h2>
<p><code>dataflow</code> encourages functional compositional style.</p>
<p>Embedded Domain Specific Language (EDSL) for Keywords: testable, composable,
orthogonal, reusable, legible ...</p>
<p>inspired by the belief that it is preferable to write code like this</p>
<p>TODO: example of a nontrivial graph</p>
<p>as opposed to the equivalent</p>
<p>TODO: the same thing written as a physicist-style loop with no abstraction</p>
<p>TODO: prove, by testing, that the two are equivalent</p>
<p>TODO: wax lyrical about how much more legible, testable, maintainable,
debuggable etc. the dataflow version is.</p>
<h2><a class="header" href="#background-where-did-this-come-from" id="background-where-did-this-come-from">Background: Where did this come from?</a></h2>
<p>Next.</p>
<p>HEP analysis code tends to process a bazillion events in the same way. This
tends to be written with <em>event loops</em>, which tend to be copy-pasted leading to
an accumulation of crap into an incomprehensible mess. Try to say this politely.</p>
<p>To stop physicists from writing pointless classes containing 2000 line methods containing some nested loops</p>
<h2><a class="header" href="#design-choices" id="design-choices">Design choices</a></h2>
<ul>
<li>Push rather than pull, because of divergence of streams</li>
<li>Namespace in a single stream to simulate parallel, synchronized, joinable streams.</li>
</ul>
<h2><a class="header" href="#concurrency" id="concurrency">Concurrency</a></h2>
<p>Obvious potential extension. Not needed by IC yet, so not worked on it yet. Should do.</p>
<p>Pitfalls:</p>
<ul>
<li>Order of arrival in sinks</li>
<li>How to combine sinks found in the middle of streams if those streams are split across multiple processors</li>
</ul>
<h1><a class="header" href="#manual" id="manual">Manual</a></h1>
<h2><a class="header" href="#fundamental-concepts" id="fundamental-concepts">Fundamental concepts</a></h2>
<p><code>dataflow</code> is an Embedded Domain Specific Language (EDSL) for expressing
computations on streams of data, built out of three fundamental kinds of
component</p>
<ul>
<li>sources</li>
<li>pipes</li>
<li>sinks</li>
</ul>
<p>Conceptually these may be connected like this</p>
<p>TODO: decide on a pretty graphical way of presenting these network diagrams</p>
<pre><code>source -&gt; pipe element 1 -&gt; pipe element 2 -&gt; ... -&gt; sink
</code></pre>
<ul>
<li>sources produce data</li>
<li>pipes transform and filter data</li>
<li>sinks consume data</li>
</ul>
<p>Pipes are <em>composable</em> and <em>reusable</em>: a pipe can be made out of smaller pipes
joined end-to-end.</p>
<p>More complex data flows, including bifurcations</p>
<pre><code>source -&gt; pipe 1 ---&gt; pipe X -&gt; pipe Y -&gt; sink Z
                \
                 pipe A -&gt; pipe B -&gt; pipe C -&gt; sink D

</code></pre>
<p>and even joins</p>
<pre><code>source -&gt; pipe 1 ---&gt; pipe X -&gt; pipe Y ---&gt; sink Z
                \                      /
                 pipe A -&gt; pipe B ____/

</code></pre>
<p>can also me made, but we will put off discussing these until later.</p>
<p>TODO: note that graph, network and data flow are synonyms</p>
<p>TODO: note that pipe and stream are almost synonymous</p>
<ul>
<li>Zero or more elements which</li>
<li>Exactly one sink, which consume</li>
</ul>
<p>TODO: introduce the 'capped pipe' terminology and emphasize that a capped pipe
is essentially a sink.</p>
<h2><a class="header" href="#the-simplest-graph-push-and-sink" id="the-simplest-graph-push-and-sink">The simplest graph: <code>push</code> and <code>sink</code></a></h2>
<p>Throughout the examples that follow, it is assumed that <code>dataflow</code> has been
imported thus (TODO: when implement executable examples, these imports might
have to be made explicit in each example)</p>
<pre><code class="language-python">import dataflow as df
</code></pre>
<p>The <code>push</code> function is used to connect sources of data to pipes which can
accept, process and consume the data. In its simplest form it looks like this:</p>
<pre><code class="language-python">df.push(source=the_source, pipe=the_pipe)
</code></pre>
<ul>
<li>The source can be any Python iterable.</li>
<li>Pipes can be made using utilities provided by <code>dataflow</code>. [Pipes are
implemented as coroutines, but most users can safely ignore this detail.]</li>
</ul>
<p>[Aside: In real life we would usually choose to push lazy sources into the
pipeline, but in the examples that follow we avoid lazy sources so that we can
verify the results more easily.]</p>
<p>The simplest possible pipeline has the source directly connected to a single
sink. This is not particularly useful: it merely serves the purpose of showing
how the basic components fit together.</p>
<pre><code class="language-python">    # Some dummy data
    the_source = list(range(20))

    # In this example the sink will simply collect the data it
    # receives, into a list.
    result = []

    # df.sink makes a sink out of a plain Python function.
    the_sink = df.sink(result.append)

    # Use df.push to feed the source into the pipe.
    df.push(source=the_source, pipe=the_sink)

    assert result == the_source
</code></pre>
<p>Points to note:</p>
<ul>
<li>
<p>In this example, the source is connected directly to the sink.</p>
<ul>
<li>
<p>There are no pipeline elements between the source and sink. This is unusual,
but perfectly ok, because ...</p>
</li>
<li>
<p><strong>Sinks have exactly the same interface as pipes at the upstream end</strong>.</p>
</li>
</ul>
</li>
<li>
<p><code>sink</code> turns a plain Python function into a sink. The function should accept
one argument, and not return anything.</p>
<ul>
<li>
<p>TODO: What happens if it <em>does</em> return something?</p>
</li>
<li>
<p>The most obvious sinks perform some side-effect using the data they receive,
such as writing it out to persistent storage, or, as in the example above,
collecting them into a list that was created earlier.</p>
</li>
<li>
<p>Rather than producing side-effects, sinks can produce return values for
<code>push</code>. TODO: refer to <code>push(result = )</code> and future-sinks later on in the
manual.</p>
</li>
</ul>
</li>
<li>
<p>This is a trivial example which does nothing beyond showing how the
fundamental components fit together.</p>
</li>
</ul>
<h2><a class="header" href="#sinks-vs-pipes" id="sinks-vs-pipes">Sinks vs. pipes</a></h2>
<p>It is worth repeating that <strong>sinks have exactly the same interface as pipes at
the upstream end</strong>.</p>
<ul>
<li>
<p>Pipes transform (or filter) data: they receive data at their upstream end, and
send data out of their downstream end.</p>
</li>
<li>
<p>Sinks consume data: no data flow out of a sink: they receive data at their
upstream end, but have no downstream end at all.</p>
</li>
<li>
<p>The data sent downstream out of a pipe have to end up somewhere: they have to
be collected by a sink!</p>
</li>
<li>
<p>Consequently, an <em>uncapped</em> pipe (one not connected to a sink at its
downstream end) cannot have any data <code>push</code>ed into it.</p>
</li>
<li>
<p>Conversely, a <em>capped</em> pipe is indistinguishable from a sink.</p>
</li>
</ul>
<p>Henceforth we should consider <strong><em>capped pipe</em></strong> to be synonymous with
<strong><em>sink</em></strong>, and remember these fundamental properties:</p>
<table><thead><tr><th></th><th align="center"><em>uncapped</em> or <em>open</em> pipe</th><th align="center"><em>capped</em> pipe or <em>sink</em></th></tr></thead><tbody>
<tr><td>Can <code>push</code> data into</td><td align="center"><span style="color:red">❌</span></td><td align="center"><span style="color:green;font-size:200%">✓</span></td></tr>
<tr><td>A pipe can be attached to the downstream end of</td><td align="center"><span style="color:green;font-size:200%">✓</span></td><td align="center"><span style="color:red">❌</span></td></tr>
</tbody></table>
<h2><a class="header" href="#creating-and-connecting-pipes-map-and-pipe" id="creating-and-connecting-pipes-map-and-pipe">Creating and connecting pipes: <code>map</code> and <code>pipe</code></a></h2>
<p>The most convenient way to create pipes, is to use utilities provided by
<code>dataflow</code>. Just like <code>df.sink</code> makes sinks (capped pipes) out of plain
functions, so <code>df.map</code> makes open (uncapped) pipes out of plain functions.</p>
<p><code>df.pipe</code> is used to chain together a number of pipes.</p>
<pre><code class="language-python">    # Some data transformation, expressed as a plain Python function, which we
    # would like to use in a pipe
    def the_operation(n):
        return n*n

    # df.map turns the function into a pipe component
    square = df.map(the_operation)

    # Some dummy data ...
    the_data = list(range(1,11))

    # ... and a sink for collecting the transformed data
    result = []
    the_sink = df.sink(result.append)

    # Use df.pipe to connect the square component to the sink, and feed the
    # data into the pipe with df.push
    df.push(source = the_data,
            pipe   = df.pipe(square, the_sink))

    assert result == list(map(the_operation, the_data))
</code></pre>
<p><code>df.pipe</code> accepts an arbitrary number of arguments. All of these must be open
pipes, with two exceptions:</p>
<ul>
<li>The last one may be a sink.</li>
<li>The first one may be a component selector, which we will discuss later on.</li>
</ul>
<p>If its last argument is a sink, <code>df.pipe</code> will return a sink; if its last
argument is an open pipe, <code>df.pipe</code> will return and open pipe.</p>
<p>Using <code>df.pipe</code> explicitly is usually not necessary, as most utilities which
accept pipes, know how to create them implicitly out of a tuple of pipe
components. TODO: once mmkekic's implicit-pipe-in-push PR has been merged,
demonstrate this with an example right here.</p>
<p>TODO: refer to the <code>args</code> etc. features of map which should be discussed later on.</p>
<h2><a class="header" href="#filter" id="filter"><code>filter</code></a></h2>
<p><code>df.filter</code> is the <code>dataflow</code> equivalent of Python's built-in <code>filter</code>, used to
discard data according to some criterion.</p>
<pre><code class="language-python">    # A predicate expressed as a plain function
    def the_predicate(n):
        return n % 2

    # Turn the predicate into a pipeline component with df.filter
    odd = df.filter(the_predicate)

    # Some dummy data ...
    the_data = list(range(20, 30))

    # ... and a sink for collecting the filtered data
    result = []
    the_sink = df.sink(result.append)

    # df.filter's result can be used in pipes
    df.push(source = the_data,
            pipe   = df.pipe(odd, the_sink))

    # df.filter is the dataflow equivalent of Python's builtin filter
    assert result == list(filter(the_predicate, the_data))
</code></pre>
<h2><a class="header" href="#sinks-without-side-effects-pushresult--" id="sinks-without-side-effects-pushresult--">Sinks without side-effects: <code>push(result = ...)</code></a></h2>
<p>The sinks we have seen so far, have all worked by side-effect: before pushing
some data through a pipeline, we created a list along with a sink which pushes
data into that list. In some situations, particularly when the sink writes data
to a file, side-effects are fine. But eschewing side-effects TODO bla bla wax
lyrical.</p>
<p>Consider that</p>
<ol>
<li>
<p>The sink must be placed at the end of a pipe.</p>
</li>
<li>
<p><code>df.push</code> must be used to push data through the pipe.</p>
</li>
<li>
<p><code>df.push</code> must stop pushing any more data through the pipe.</p>
</li>
<li>
<p>Only <em>then</em> will the sink have enough information to produce the final
result.</p>
</li>
</ol>
<p>How can you retrieve the value returned by the sink, if the sink is wrapped
inside a pipe inside a call to <code>df.push</code>? The solution is to create, alongside
the sink itself, another object which will allow you to access the final result,
once it becomes available.</p>
<p>For this purpose <code>dataflow</code> uses the <code>Future</code> found in Python's standard
<code>asyncio</code> module, but this is an implementation detail which most users can
forget, because <code>dataflow</code> provides a higher-level interface for retrieving sink
results via the value returned by <code>df.push</code>.</p>
<pre><code class="language-python">    # Some dummy data
    the_source = list(range(100))

    # df.count is a sink factory. It creates a sink which counts how many
    # values it is fed. Once the stream has been closed, it places the final
    # result in its corresponding future.
    count = df.count()

    # df.count returns a namedtuple ...
    assert isinstance(count, tuple)

    # ... which contains a future as its first element ...
    assert count.future is count[0]

    # ... and a sink as the second element.
    assert count.sink is count[1]

    result = df.push(source = the_source,
                     # The sink can be used to cap a pipe
                     pipe   = count.sink,
                     # The future can be used to specify the return value of df.push
                     result = count.future)

    # When push finishes streaming data into its pipe, it will extract the
    # value it is supposed to return from the future it was given.
    assert result == len(the_source)
</code></pre>
<h3><a class="header" href="#returning-more-than-one-value-using-pushresult--" id="returning-more-than-one-value-using-pushresult--">Returning more than one value using <code>push(result = ...)</code></a></h3>
<p>Later we will see that a single network may contain multiple sinks, at which
point it becomes interesting to instruct <code>pipe</code> to return the values
created by an arbitrary subset of these sinks.</p>
<p>Consequently, <code>push(result = ...)</code> can accept</p>
<ul>
<li>a single future</li>
<li>a tuple of futures</li>
<li>a dictionary of futures</li>
</ul>
<p>In each case, <code>push</code> will return a similarly-shaped object containing the
values extracted from the futures:</p>
<pre><code class="language-python">push(..., result =        a.future             ) # -&gt;        &lt;value a&gt;
push(..., result =     (  a.future,   b.future)) # -&gt;     (  &lt;value a&gt;,     &lt;value b&gt;)
push(..., result = dict(a=a.future, b=b.future)) # -&gt; dict(a=&lt;value a&gt;, b = &lt;value b&gt;)
</code></pre>
<h2><a class="header" href="#diy-side-effect-free-sinks-reduce" id="diy-side-effect-free-sinks-reduce">DIY side-effect-free sinks: <code>reduce</code></a></h2>
<p><code>map</code>, <code>filter</code> and <code>reduce</code> (sometimes known under different names, such as
<code>transform</code>, <code>accumulate</code> and <code>fold</code>) are three of the most common higher-order
loop-abstraction functions, ubiquitous in functional programming, and finding
their way into most programming languages these days.</p>
<p>They fall into two distinct categories. All three consume iterables, but</p>
<ul>
<li><code>map</code> and <code>filter</code> return iterables</li>
<li><code>reduce</code> returns a single[*] value</li>
</ul>
<!-- [Aside: This is not strictly true. `reduce` is the most fundamental -->
<!-- loop-abstraction function, in the sense that, in theory, **any** loop (including -->
<!-- those which produce non-scalar results) can be expressed in terms of `reduce`; -->
<!-- in practice it is often more trouble than it is worth!] -->
<p>This dichotomy hints at the different roles their equivalents play in <code>dataflow</code>:</p>
<ul>
<li><code>df.map</code> and <code>df.filter</code> make uncapped (open) pipes,</li>
<li><code>df.reduce</code> makes capped pipes (sinks).</li>
</ul>
<p><code>df.reduce</code> provides a high-level means of creating future-sinks such as
<code>df.count</code> (which we saw earlier) or <code>df.sum</code> (which sums all the values
receives). Here is how you would use <code>df.reduce</code> to make the latter</p>
<p>TODO: <code>df.sum</code> is not implemented yet, is it?</p>
<pre><code class="language-python">    # Some dummy data, for testing
    the_data = list(range(15))

    # A binary function which returns the sum of its arguments
    from operator import add
    # Alternatively, we could have defined this ourselves as
    # def add(a, b):
    #     return a + b

    # df.reduce can be used to turn a binary function into a sink factory
    df_sum = df.reduce(add, initial=0)

    # The factory returns a namedtuple containing a future and sink
    ssum = df_sum()

    result = df.push(source = the_data,
                     # The sink can be used to cap a pipe
                     pipe   = ssum.sink,
                     # The future can be used to specify the return value of push
                     result = ssum.future)
    # The component we created is the dataflow equivalent of Python's builtin
    # sum
    assert result == sum(the_data)
</code></pre>
<h2><a class="header" href="#spy-side-effects-in-the-middle-of-a-pipe" id="spy-side-effects-in-the-middle-of-a-pipe"><code>spy</code>: side-effects in the middle of a pipe</a></h2>
<p><code>spy</code> is used to create uncapped pipes which do not modify the data flowing
through them in any way: inserting a spy into a pipe should not affect what
flows downstream. Instead, they can use the data to perform arbitrary
side-effects. An obvious application would be to insert <code>spy(print)</code> into a pipe
in order to observe what is flowing through the pipe at that point.</p>
<pre><code class="language-python">    # Some data for testing
    the_data = list(range(50, 60))

    # A sink to collect everything that reaches the end of the pipe
    reached_the_end = []; the_sink = df.sink(reached_the_end.append)
    # A spy to observe (and collect) everything mid-pipe
    spied           = []; the_spy  = df.spy (          spied.append)

    df.push(source = the_data,
            # Insert the spy into the pipe before the sink
            pipe   = df.pipe(the_spy, the_sink))

    # The spy saw all the data flowing through the pipe ...
    assert           spied == the_data
    # ... but didn't affect what was seen downstream
    assert reached_the_end == the_data
</code></pre>
<p>If the data flowing through the pipe are mutable, the spy could mutate them, and
thus modify what gets sent downstream, but this is <em>not</em> the intended use of
spies: don't do that!</p>
<h2><a class="header" href="#splitting-streams-fork-and-branch" id="splitting-streams-fork-and-branch">Splitting streams: <code>fork</code> and <code>branch</code></a></h2>
<p><code>dataflow</code> provides two utilities for bifurcating a data stream: that is to say,
sending the data arriving at some point into more than one downstream pipe.</p>
<p>They are called <code>fork</code> and <code>branch</code>, and are equivalent in power but some ideas
may be more naturally expressed in terms of one or the other.</p>
<pre><code class="language-python">    # Some pipeline components
    c1 = []; C1 = df.sink(c1.append)
    c2 = []; C2 = df.sink(c2.append)
    e1 = []; E1 = df.sink(e1.append)
    e2 = []; E2 = df.sink(e2.append)

    A = df.map(lambda n:n+1)
    B = df.map(lambda n:n*2)
    D = df.map(lambda n:n*3)

    # graph1 and graph2 are eqivalent networks. graph1 is constructed with
    # fork ...
    graph1 = df.pipe(A, df.fork((B,C1),
                                (D,E1)))
    # ... while graph2 is built with branch.
    graph2 = df.pipe(A, df.branch(B,C2), D,E2)

    # Feed the same data into the two networks.
    the_data = list(range(10, 50, 4))
    df.push(source=the_data, pipe=graph1)
    df.push(source=the_data, pipe=graph2)

    # Confirm that both networks produce the same results.
    assert c1 == c2
    assert e1 == e2
</code></pre>
<p>Visually, the <code>fork</code> version suggests a layout like this</p>
<pre><code>              B -&gt; C
             /
the_data -&gt; A
             \
              D -&gt; E
</code></pre>
<p>while the <code>branch</code> version looks more like this</p>
<pre><code>                   B -&gt; C
                  /
the_data -&gt; A -&gt; o -&gt; D -&gt; E
</code></pre>
<p>but their topologies, and hence their behaviours, are identical.</p>
<p>The main differences are:</p>
<ul>
<li>
<p><code>branch</code> accepts exactly one pipe; <code>fork</code> accepts an arbitrary number</p>
</li>
<li>
<p><code>branch</code> creates uncapped (open) pipes; <code>fork</code> creates capped pipes (sinks).</p>
</li>
</ul>
<h3><a class="header" href="#use-branch-to-make-spies-out-of-sinks" id="use-branch-to-make-spies-out-of-sinks">Use <code>branch</code> to make spies out of sinks</a></h3>
<p><code>branch</code>, like <code>spy</code>, allows you to insert operations on the stream of data
flowing through any point in a network, without affecting what flows downstream.
In contrast to <code>spy</code> (which accepts a single plain function), <code>branch</code> accepts
an arbitrary number (maybe zero) of open pipes followed by exactly one sink. It
combines these to make a capped pipe into which it sends all data it sees, in
addition to allowing the same data to flow downstream. Consequently <code>branch</code> can
be thought of as a way of making spies out of capped pipes or sinks.</p>
<p>TODO: create the following example</p>
<pre><code class="language-python">
</code></pre>
<h2><a class="header" href="#todo-tests-not-used-here-so-far" id="todo-tests-not-used-here-so-far">TODO Tests not used here so far</a></h2>
<ul>
<li><code>test_fork</code></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        
                            <a rel="next" href="chapter_1.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
                    <a href="chapter_1.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
